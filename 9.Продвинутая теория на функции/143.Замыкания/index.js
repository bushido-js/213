//Понятие замыкание (closure)
//Итак, замыкание - это функция вместе со всеми внешними переменными, которые ей доступны. Или, другими словами, замыкание - это функция вместе со своим лексическим окружением.

// В JavaScript чаще всего, говоря "замыкание функции", имеют ввиду не саму эту функцию, а именно ее внешние переменные. Если же какая-то функция получает переменную из своего лексического окружения, то говорят "переменная берется из замыкания".


//Самостоятельно, не подсматривая в мой код, реализуйте счетчик вызова функции, работающий на замыканиях.

    // function test() {
    //   let num = 1;
    //   return function () {
    //     console.log(num);
    //     num++;
    //   }
    // }

    // let func = test();
    // func();
    // func();
    // func();
  //Это счётчик вызова функции работающий на замыканиях

// Пусть функция в замыкании хранит число 10. Сделайте так, чтобы каждый вызов функции уменьшал это число на 1 и выводил на экран уменьшенное число.

  // function test() {
  //   let num = 10;
  //   return function () {
  //     for(let i = num; i > 0; i--){
  //       console.log(num);
  //       num--;
  //     }
  //     if (num == 0){
  //       alert('Отсчёт закончен')
  //     }
  //   }
  // }
  // let func = test();
  // func()

// Модифицируйте предыдущую задачу так, чтобы отсчет доходил до 0, а затем каждый последующий вызов функции выводил на экран сообщение о том, что отсчет окончен.
//Решение выше

  // function func() {
  // 	let num = 0;
    
  // 	return function() {
  // 		alert(num);
  //     num++;
  // 	};
  // };

  // func()();
  // func()();
  // func()();

  // function func() {
  //   let num = 0;
    
  //   return function() {
  //     alert(num);
  //     num++;
  //   };
  // };
  
  // let test = func;
  
  // test()();
  // test()();
  // test()();

//Любопытный НЮАНС 
  // Дело в том, что переменная num - локальная внутри функции test. Поэтому каждый вызов test порождает свою локальную переменную.

  // Поэтому возвращаемые функции будут ссылаться каждая на свою локальную переменную функции test. Именно так и достигается независимость работы.

  // Если же сделать num глобальной переменной - это тоже будет замыканием. Просто лексические окружения возвращаемых функций ссылаются на одну и ту же переменную num - любые изменения с этой переменной будут видны во всех функциях.

  // let counter = 0;
		
  // function test() {
  //   return function() {
  //     alert(counter);
  //     counter++;
  //   };
  // };
  
  // let func = test;
  
  // let func1 = func();
  // let func2 = func();
  // func1();
  // func2();
  // func1();
  // func2();

  // function test() {
  //   let counter = 0;
    
  //   return function() {
  //     return function() {
  //       alert(counter);
  //       counter++;
  //     };
  //   };
  // };
  
  // let func = test()();
  
  // let func1 = func;
  // let func2 = func;
  // func1();
  // func2();
  // func1();
  // func2();

  function test() {
    let counter = 0;
    
    return function() {
      return function() {
        console.log(counter);
        counter++;
      };
    };
  };
  
  let func = test();
  
  let func1 = func();
  let func2 = func();
  func1();
  func2();
  func1();
  func2();



